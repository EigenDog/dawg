(** types for the protocol between the master and worker, and among
    workers.  There is at most one worker per host, serving on a
    pre-determined port (as a means of achieving uniqueness) *)

type worker_id = string
type task_id = string
type host = string
type feature_id = int

type id = {
  worker_id : worker_id ;
  user : string ; (* name of user owning the worker process *)
}

type known_worker = (worker_id * host list)
(* a worker peer may be accessible via multiple ip addresses (eg
   when a host has more than one network interface) *)

type known_workers = known_worker list

type setup = {
  y_feature_id : feature_id;
  fold_feature_id : feature_id option;

  local_dog_path : string option;
  (* tell the worker to initialize itself using the dog file at the
     specified path on its host; the worker will have access to the
     dog file's features *)

}

type ufeature <ocaml_biniou module="Dog_b" ocaml_json module="Dog_j">= abstract
type ifeature <ocaml_biniou module="Dog_b" ocaml_json module="Dog_j">= abstract

type point = {
  (* what is the value of the piecewise function at the split? *)
  s_gamma : float ;

  (* how many observations does the split cover? *)
  s_n : int ;

  (* what is the loss? *)
  s_loss  : float ;
}

type ordinal_split = {
  os_feature_id : feature_id ;
  os_split : int ;
  os_left : point ;
  os_right : point ;
}

type categorical_split = (ordinal_split * int list <ocaml repr="array">)

type split = [
  | OrdinalSplit of ordinal_split
  | CategoricalSplit of categorical_split
]

type push = {
  feature_id : feature_id ;
  split : split
}

type to_worker_in_working = [
  | Setup of setup
  (* tell the worker about the task; the worker will look for the
     target and fold features, so, unless it is also given the
     complete dog file path, it better have at least one collaborating
     peer to find them *)

  | GetFeaturesFromPeers of ufeature list
  (* instruct the worker to acquire these features from any of its
     collaborating peers, if it doesn't already have them; it is not
     guaranteed that a collaborating peer has that feature. *)

  | GetFeatures of feature_id list
  (* get feature _data_ (rather than metadata), from _this_ worker
     (rather than its peers *)

  | SetRandomSeed of int list

  | AddFeatures of (feature_id list * [BestAndPartition | PartitionOnly])
  (* add a feature to the set used for finding a best split, or used
     for partitioning of the observations; a feature may
     simultaneously serve as both *)

  | Sample

  | BestSplit
  (* get the best split among all the features which are elements of
     the [Best] set *)

  | Push of push

  | Ascend

  | Descend of [Left | Right]

  | CopyFeatures of (feature_id * string) list
]

type copy_feature = {
  feature : ifeature;
  vector : string
}

type to_worker_copying = [
  | Copy of copy_feature list
  (* add features to the feature map *)
]

type to_worker = [
  | Heel of task_id
  (* client tries to assert his ownership of worker *)

  | Id
  (* what is the worker id? *)

  | InformPeerHosts of host list
  (* tell the worker of one its peers; it may or may not collaborate
     on the worker's task *)

  | Working of (task_id * to_worker_in_working)



]

type from_worker = [
  | Error of string
  | AckId of id
  | AckBestSplit of split option
  | AckSample
  | AckHeel
  | AckSetup
  | AckSetRandomSeed
  | AckAddFeatures
  | AckPush
  | AckAscend
  | AckDescend
  | AckCopyFeatures
]
