(** types for the protocol between the master and worker, and among
    workers.  There is at most one worker per host, serving on a
    pre-determined port (as a means of achieving uniqueness) *)

type worker_id = string
type task_id = string
type host = string
type feature_id = int

type id = {
  worker_id : worker_id ;
  user : string ; (* name of user owning the worker process *)
}

type known_worker = (worker_id * host list)
(* a worker peer may be accessible via multiple ip addresses (eg
   when a host has more than one network interface) *)

type known_workers = known_worker list

type 'a task = (task_id * 'a)

type setup = {
  y_feature_id : feature_id;
  fold_feature_id : feature_id option;

  local_dog_path : string option;
  (* tell the worker to initialize itself using the dog file at the
     specified path on its host; the worker will have access to the
     dog file's features *)

}

type ufeature <ocaml_biniou module="Dog_b" ocaml_json module="Dog_j">= abstract

type point = {
  (* what is the value of the piecewise function at the split? *)
  s_gamma : float ;

  (* how many observations does the split cover? *)
  s_n : int ;

  (* what is the loss? *)
  s_loss  : float ;
}

type ordinal_split = {
  os_feature_id : feature_id ;
  os_split : int ;
  os_left : point ;
  os_right : point ;
}

type categorical_split = (ordinal_split * int list <ocaml repr="array">)

type split = [
  | OrdinalSplit of ordinal_split
  | CategoricalSplit of categorical_split
]

type push = {
  feature_id : feature_id ;
  direction : [ Right | Left ];
  split : split
}

type to_worker = [
  | Heel of task_id
  (* client tries to assert his ownership of worker *)

  | Setup of setup task
  (* tell the worker about the task; the worker will look for the
     target and fold features, so, unless it is also given the complete
     dog file path, it better have at least one collaborating peer to find them *)

  | Id
  (* what is the worker id? *)

  | InformPeerHosts of host list
  (* tell the worker of one its peers; it may or may not collaborate
     on the worker's task *)

  | GetFeaturesFromPeers of ufeature list task
  (* instruct the worker to acquire these features from any of its
     collaborating peers, if it doesn't already have them; it is not
     guaranteed that a collaborating peer has that feature. *)

  | GetFeatures of feature_id list
  (* get feature _data_ (rather than metadata), from _this_ worker
     (rather than its peers *)

  | SetRandomSeed of int list task

  | AddFeatures of (feature_id list * [BestAndPartition | PartitionOnly]) task
  (* add a feature to the set used for finding a best split, or used
     for partitioning of the observations; a feature may
     simultaneously serve as both *)

  | BestSplit of task_id
  (* get the best split among all the features which are elements of
     the [Best] set *)

  | Push of push
  (* 'descend' to a subpopulation of the observations indicated by [push.split] *)

  | Pop (* ascend *)

]

type bad_state = [
  | Busy of task_id (* worker is busy working on another task *)
  | Idle (* worker is unemployed, that is, not working for any master *)
]
type common_ack = [ inherit bad_state | Ok ]
type dont_have_features = [ inherit common_ack | DontHaveFeatures of feature_id list ]

type from_worker = [
  | AckHeel of common_ack
  | AckSetupLocalDogFile of common_ack
  | AckSetup of dont_have_features
  | AckSetRandomSeed of common_ack
  | AckAddFeatures of dont_have_features
  | AckBestSplit of [ Ok of split | None | Busy of task_id ]
  | AckId of id
  | AckPush of dont_have_features
  | AckPop of [ inherit common_ack | Empty (* nothing to pop! *) ]
]
